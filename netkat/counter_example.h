// Copyright 2025 The NetKAT authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef GOOGLE_NETKAT_NETKAT_COUNTER_EXAMPLE_H_
#define GOOGLE_NETKAT_NETKAT_COUNTER_EXAMPLE_H_

#include <optional>
#include <ostream>
#include <string>
#include <utility>
#include <vector>

#include "absl/container/flat_hash_set.h"
#include "absl/log/check.h"
#include "netkat/evaluator.h"
#include "netkat/packet_set.h"
#include "netkat/packet_transformer.h"

namespace netkat {

using OutputPackets = absl::flat_hash_set<Packet>;

// A counter example contains the difference between two policies and the
// corresponding input/output packets that belong to one policy, but not the
// other and vice versa.
//
// Note: The lifetime of `CounterExample` is dependent on the
// lifetime of the `PacketTransformerManager` that created it.
class CounterExample {
 public:
  static absl::StatusOr<CounterExample> CreateEquivalenceCounterExample(
      PacketTransformerManager* packet_transformer_manager,
      PacketTransformerHandle left_policy,
      PacketTransformerHandle right_policy);

  PacketTransformerHandle GetLeftTransformer() const;
  PacketTransformerHandle GetRightTransformer() const;

  // Returns the input packet set that holds in the left transformer, but not
  // the right transformer. The counterexample is represented by the following:
  // PacketSetHandle := Pull(left policy - right policy, FullSet).
  PacketSetHandle GetInputPacketsInLeftButNotRight() const;

  // Returns the input packet set that holds in the right transformer, but not
  // the left transformer. The counterexample is represented by the following:
  // PacketSetHandle := Pull(right policy - left policy, FullSet).
  PacketSetHandle GetInputPacketsInRightButNotLeft() const;

  // Returns the set of input packets that are in both left and right policies.
  PacketSetHandle GetInputPacketsInBoth() const;

  // Returns the packet set's dot representation for the counterexample or die.
  // The counterexample is represented by the following:
  // PacketSetHandle := Pull(left policy - right policy, FullSet).
  std::string GetInputFromLeftButNotRightAsDotOrDie() const;

  // Returns the packet set's dot representation for the counterexample or die.
  // The counterexample is represented by the following:
  // PacketSetHandle := Pull(right policy - left policy, FullSet).
  std::string GetInputFromRightButNotLeftAsDotOrDie() const;

  // Returns a map from input packets to output packets for the counterexample
  // or die. The set of input packets is represented by the following:
  // PacketSetHandle := Pull(left policy - right policy, FullSet).
  // The set of outputs are generated by sending the input packets through
  // corresponding transformer.
  std::vector<std::pair<Packet, OutputPackets>>
  GetInputPacketToOutputPacketsForLeftDiffRightPoliciesOrDie() const;

  // Returns a map from input packets to output packets for the counterexample
  // or die. The set of input packets is represented by the following:
  // PacketSetHandle := Pull(right policy - left policy, FullSet).
  // The set of outputs are generated by sending the input packets through
  // corresponding transformer.
  std::vector<std::pair<Packet, OutputPackets>>
  GetInputPacketToOutputPacketsForRightDiffLeftPoliciesOrDie() const;

 private:
  CounterExample(PacketTransformerManager* packet_transformer_manager,
                 PacketTransformerHandle left_packet_transformer,
                 PacketTransformerHandle right_packet_transformer);

  PacketTransformerManager* packet_transformer_manager_;
  PacketTransformerHandle left_packet_transformer_;
  PacketTransformerHandle right_packet_transformer_;
  PacketSetHandle input_packets_in_left_but_not_right_;
  PacketSetHandle input_packets_in_right_but_not_left_;
};

template <typename Sink>
void AbslStringify(Sink& sink, const CounterExample& counter_example);
std::ostream& operator<<(std::ostream& os,
                         const CounterExample& counter_example);

// A success or counter example is a wrapper around a counter example.
// If the two policies compared in the analysis engine are the same, the
// SuccessOrCounterExample should have no counter example and return true when
// IsSuccess is called. Otherwise, if IsSuccess returns false, then the
// SuccessOrCounterExample will contain a counter example.
class SuccessOrCounterExample {
 public:
  SuccessOrCounterExample() = default;
  explicit SuccessOrCounterExample(CounterExample counter_example)
      : counter_example_(std::move(counter_example)) {}

  bool IsSuccess() const { return !counter_example_.has_value(); }

  const CounterExample& GetCounterExampleOrDie() const {
    CHECK(counter_example_.has_value());
    return *counter_example_;
  }

 private:
  std::optional<CounterExample> counter_example_;
};

template <typename Sink>
void AbslStringify(Sink& sink,
                   const SuccessOrCounterExample& success_or_counter_example);
std::ostream& operator<<(
    std::ostream& os,
    const SuccessOrCounterExample& success_or_counter_example);

}  // namespace netkat

#endif  // GOOGLE_NETKAT_NETKAT_COUNTER_EXAMPLE_H_
